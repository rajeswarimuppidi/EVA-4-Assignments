# -*- coding: utf-8 -*-
"""Copy of Python101.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BJx-uMOVE8o6xzmBeDuEdV3F-9SmCgR8

# Python 101
![alt text](https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRZpTmijaNOH6MmycM_eiPKcEl5mVvbwl7a8YKVGpEEMIanDcSt)

This is a MUST Python Refresher. You must finish this notebook as a part of overall grading.

Majority of this notebook is inspired from: Stanford's Python Refresher which can be found at: https://cs231n.github.io/python-numpy-tutorial/



---

**We have modified the original notebook and added some questions here. You need to find the solutions and provide answers in your Q1 - Python 101 Quiz.**

# Python
Python is a high-level, dynamically typed multiparadigm programming language. Python code is often said to be almost like pseudocode, since it allows you to express very powerful ideas in very few lines of code while being very readable.

---

## Python Versions

There are currently two different supported versions of Python, 2.7 and 3.5. Somewhat confusingly, Python 3.0 introduced many backwards-incompatible changes to the language, so code written for 2.7 may not work under 3.5 and vice versa. For this class all code will use Python 3.5 or higher.

You can check your Python version at the command line by running `python --version`
"""

!python --version

"""## Basic data types

Like most languages, Python has a number of basic types including integers, floats, booleans, and strings. These data types behave in ways that are familiar from other programming languages.

**Numbers**: Integers and floats work as you would expect from other languages:
"""

x = 37 # Initial Value of x
print(type(x)) # Prints "<class 'int'>"
print(x)       # Prints "3"
print(x + 1)   # Addition; prints "4"
print(x - 1)   # Subtraction; prints "2"
print(x * 2)   # Multiplication; prints "6"
print(x ** 2)  # Exponentiation; prints "9"
x += 1
print(x)  # Prints "4"
x *= 2
print(x)  # Prints "8"
y = 2.5
print(type(y)) # Prints "<class 'float'>"
print(y, y + 1, y * 2, y ** 2) # Prints "2.5 3.5 5.0 6.25"

x = x * y + x + y # Final value of x
print("Final Value of x is:", x)

"""# Quiz Question 1
With what integer value shall x be initialized as, such that Final Value of x is 268.5? Please mention the answer in INT value without decimal (e.g. 4, 2, 12, etc.).

Please answer this question in the Quiz Section.



---

**Booleans**

Python implements all of the usual operators for Boolean logic, but uses English words rather than symbols (&&, ||, etc.):
"""

t = True
f = False
print(type(t)) # Prints "<class 'bool'>"
print(t and f) # Logical AND; prints "False"
print(t or f)  # Logical OR; prints "True"
print(not t)   # Logical NOT; prints "False"
print(t != f)  # Logical XOR; prints "True"

"""# Quiz Question 2
What is the value of 

```
not ( not t + f * t)
```
if executed after the code block above?
"""

print(not ( not t + f * t))

"""**Strings**

Python has great support for strings:
"""

hello = 'hello'    # String literals can use single quotes
world = "world"    # or double quotes; it does not matter.
print(hello)       # Prints "hello"
print(len(hello))  # String length; prints "5"
hw = hello + ' ' + world  # String concatenation
print(hw)  # prints "hello world"
hw6 = '%s %s %d' % (hello, world, 6)  # sprintf style string formatting
print(hw6)  # prints "hello world 6"

location = 0
print(hw6[location])

"""# Quiz Question 3

What should be the value of "location" such that print(hw6[location]) prints 6?
"""

print(hw6[-1])

"""## Containers

Python includes several built-in container types: lists, dictionaries,sets, and tuples.

**Lists**
A list is the Python equivalent of an array, but is resizeable and can contain elements of different types:
"""

xs = [3, 1, 2]    # Create a list
print(xs, xs[2])  # Prints "[3, 1, 2] 2"
print(xs[-1])     # Negative indices count from the end of the list; prints "2"
xs[2] = 'foo'     # Lists can contain elements of different types
print(xs)         # Prints "[3, 1, 'foo']"
xs.append('bar')  # Add a new element to the end of the list
print(xs)         # Prints "[3, 1, 'foo', 'bar']"
x = xs.pop()      # Remove and return the last element of the list
print(x, xs)      # Prints "bar [3, 1, 'foo']"

rng = 5
nums = list(range(rng))     # range is a built-in function that creates a list of integers
print(nums)               # Prints "[0, 1, 2, 3, 4]"
print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"
print(nums[2:])           # Get a slice from index 2 to the end; prints "[2, 3, 4]"
print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints "[0, 1]"
print(nums[:])            # Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"
print(nums[:-1])          # Slice indices can be negative; prints "[0, 1, 2, 3]"
nums[2:4] = [8, 9]        # Assign a new sublist to a slice
print(nums)               # Prints "[0, 1, 8, 9, 4]"
print(sum(nums))

"""# Quiz Question 4

What should be the value of rng, such that print(sum(nums)) prints 48?
"""

rng = 9
nums = list(range(rng))     
nums[2:4] = [8, 9]        
print(sum(nums))

"""**Loops**

You can loop over elements of a list like this:
"""

animals = ['cat', 'dog', 'monkey']
for animal in animals:
    print(animal)

"""If you want access to the index of each element within the body of a loop, use the built-in `enumerate` function:"""

animals = ['cat', 'dog', 'monkey']
for idx, animal in enumerate(animals):
    print('#%d: %s' % (idx + 1, animal))

"""**List comprehensions**

When programming, frequently we want to transform one type of data into another. As a simple example, consider the following code that computes square numbers:
"""

rng2 = 3
nums = range(rng2)
squares = []
for x in nums:
    squares.append(x ** 2)
print(sum(squares))

"""# Quiz Question 5
What should be the value of rng2, such that the code block above prints 91?
"""

rng2 = 7
nums = range(rng2)
squares = []
for x in nums:
    squares.append(x ** 2)
print(sum(squares))

"""You can make this code simpler using a **list comprehension**:"""

nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print(squares)

"""List comprehensions can also contain **conditions**:"""

rng3 = 4
nums = range(rng3)
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print(sum(even_squares))

"""# Quiz Question 6

What is the **sum of the two values** to which rng3 can be set such that the output above is 364?
"""

rng3 = 13
nums = range(rng3)
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print(sum(even_squares))

"""## Dictionaries

A dictionary stores (key, value) pairs, similar to a `Map` in Java or an object in Javascript. You can use it like this:
"""

d = {'cat': 'cute', 'dog': 'furry'}  # Create a new dictionary with some data
print(d['cat'])       # Get an entry from a dictionary; prints "cute"
print('cat' in d)     # Check if a dictionary has a given key; prints "True"
d['fish'] = 'wet'     # Set an entry in a dictionary
print(d['fish'])      # Prints "wet"
# print(d['monkey'])  # KeyError: 'monkey' not a key of d
print(d.get('monkey', 'N/A'))  # Get an element with a default; prints "N/A"
print(d.get('fish', 'N/A'))    # Get an element with a default; prints "wet"
del d['fish']         # Remove an element from a dictionary
print(d.get('fish', 'N/A')) # "fish" is no longer a key; prints "N/A"

"""**Loops**: It is easy to iterate over the keys in a dictionary:"""

d = {'person': 2, 'cat': 4, 'spider': 8}
for animal in d:
    legs = d[animal]
    print('A %s has %d legs' % (animal, legs))

"""If you want access to keys and their corresponding values, use the `items` method:"""

d = {'person': 2, 'cat': 4, 'spider': 8}
for animal, legs in d.items():
    print('A %s has %d legs' % (animal, legs))

"""**Dictionary comprehensions**

These are similar to list comprehensions, but allow you to easily construct dictionaries. For example:
"""

nums = [0, 1, 2, 3, 4]
even_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}
print(even_num_to_square)

"""## Sets
A set is an unordered collection of distinct elements. As a simple example, consider the following:
"""

animals = {'cat', 'dog'}
print('cat' in animals)   # Check if an element is in a set; prints "True"
print('fish' in animals)  # prints "False"
animals.add('fish')       # Add an element to a set
print('fish' in animals)  # Prints "True"
print(len(animals))       # Number of elements in a set; prints "3"
animals.add('cat')        # Adding an element that is already in the set does nothing
print(len(animals))       # Prints "3"
animals.remove('cat')     # Remove an element from a set
print(len(animals))       # Prints "2"

"""## Functions


Python functions are defined using the def keyword. For example:
"""

def sign(x):
    if x > 0:
        return 'positive'
    elif x < 0:
        return 'negative'
    else:
        return 'zero'

for x in [-1, 0, 1]:
    print(sign(x))

"""We will often define functions to take optional keyword arguments, like this:"""

def hello(name, loud=False):
    if loud:
        print('HELLO, %s!' % name.upper())
    else:
        print('Hello, %s' % name)

hello('Bob') # Prints "Hello, Bob"
hello('Fred', loud=True)  # Prints "HELLO, FRED!"

"""## Classes

The syntax for defining classes in Python is straightforward:
"""

class Greeter(object):

    # Constructor
    def __init__(self, name):
        self.name = name  # Create an instance variable

    # Instance method
    def greet(self, loud=False):
        if loud:
            print('HELLO, %s!' % self.name.upper())
        else:
            print('Hello, %s' % self.name)

g = Greeter('Fred')  # Construct an instance of the Greeter class
g.greet()            # Call an instance method; prints "Hello, Fred"
g.greet(loud=True)   # Call an instance method; prints "HELLO, FRED!"

"""# Quiz Question 7

What does g.greet(lout=False) prints above?
"""

print(g.greet(loud=False))

"""# Numpy


Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays. If you are already familiar with MATLAB, you might find [this tutorial](https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html) useful to get started with Numpy.



---


Arrays
A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.

We can initialize numpy arrays from nested Python lists, and access elements using square brackets:
"""

import numpy as np

a = np.array([1, 2, 3])   # Create a rank 1 array
print(type(a))            # Prints "<class 'numpy.ndarray'>"
print(a.shape)            # Prints "(3,)"
print(a[0], a[1], a[2])   # Prints "1 2 3"
a[0] = 5                  # Change an element of the array
print(a)                  # Prints "[5, 2, 3]"

b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array
print(b.shape)                     # Prints "(2, 3)"
print(b[0, 0], b[0, 1], b[1, 0])   # Prints "1 2 4"

print(sum(sum(a)*sum(b)))

"""# Quiz Question 8

What should a[0] be set equal to such that print(sum(sum(a)*sum(b))) prints 420?




---


Numpy also provides many functions to create arrays:
"""

import numpy as np

a = np.zeros((2,2))   # Create an array of all zeros
print(a)              # Prints "[[ 0.  0.]
                      #          [ 0.  0.]]"

b = np.ones((1,2))    # Create an array of all ones
print(b)              # Prints "[[ 1.  1.]]"

c = np.full((2,2), 7)  # Create a constant array
print(c)               # Prints "[[ 7.  7.]
                       #          [ 7.  7.]]"

d = np.eye(2)         # Create a 2x2 identity matrix
print(d)              # Prints "[[ 1.  0.]
                      #          [ 0.  1.]]"

e = np.random.random((2,2))  # Create an array filled with random values
print(e)                     # Might print "[[ 0.91940167  0.08143941]
                             #               [ 0.68744134  0.87236687]]"
print(np.prod(e))

"""# Quiz Question 9

Is it guaranteed that print(np.prod(e)) will always be less than 1?
"""

yes

"""## Array indexing

Numpy offers several ways to index into arrays.

**Slicing**
Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, you must specify a slice for each dimension of the array:
"""

import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
a[0, 0] = 4

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# A slice of an array is a view into the same data, so modifying it
# will modify the original array.
print(a[0, 1])   # Prints "2"
b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]
print(a[0, 1])   # Prints "77"

c = a[:1, 2:4]
c[0, 0] = 99

"""# Quiz Question 10
At which index of a, 99 values is stored? See quiz for options.
"""

print(a[0,2])

"""You can also mix integer indexing with slice indexing. However, doing so will yield an array of lower rank than the original array. Note that this is quite different from the way that MATLAB handles array slicing:"""

import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
row_r1 = a[1, :]    # Rank 1 view of the second row of a
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
print(row_r1, row_r1.shape)  # Prints "[5 6 7 8] (4,)"
print(row_r2, row_r2.shape)  # Prints "[[5 6 7 8]] (1, 4)"

# We can make the same distinction when accessing columns of an array:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # Prints "[ 2  6 10] (3,)"
print(col_r2, col_r2.shape)  # Prints "[[ 2]
                             #          [ 6]
                             #          [10]] (3, 1)"

"""Integer array indexing: When you index into numpy arrays using slicing, the resulting array view will always be a subarray of the original array. In contrast, integer array indexing allows you to construct arbitrary arrays using the data from another array. Here is an example:"""

import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

# An example of integer array indexing.
# The returned array will have shape (3,) and
print(a[[0, 1, 2], [0, 1, 0]])  # Prints "[1 4 5]"

# The above example of integer array indexing is equivalent to this:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints "[1 4 5]"

# When using integer array indexing, you can reuse the same
# element from the source array:
print(a[[0, 0], [1, 1]])  # Prints "[2 2]"

# Equivalent to the previous integer array indexing example
print(np.array([a[0, 1], a[0, 1]]))  # Prints "[2 2]"

"""## Datatypes

Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:
"""

import numpy as np

x = np.array([1, 2])   # Let numpy choose the datatype
print(x.dtype)         # Prints "int64"

x = np.array([1.0, 2.0])   # Let numpy choose the datatype
print(x.dtype)             # Prints "float64"

x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype
print(x.dtype)                         # Prints "int64"

"""## Array math

Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions in the numpy module:
"""

import numpy as np

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Elementwise sum; both produce the array
# [[ 6.0  8.0]
#  [10.0 12.0]]
print(x + y)
print(np.add(x, y))

# Elementwise difference; both produce the array
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
# [[ 5.0 12.0]
#  [21.0 32.0]]
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

"""Note that unlike MATLAB, `*` is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects:"""

import numpy as np

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

# Matrix / vector product; both produce the rank 1 array [29 67]
print(x.dot(v))
print(np.dot(x, v))

# Matrix / matrix product; both produce the rank 2 array
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))

"""# Quiz Question 11

What is the value of the square-root of sum of the dot product between y and the square-root of x? (answer up to 5 decimal points only, e.g. 0.12345)
"""

print(np.sqrt(np.sum(np.dot(y,np.sqrt(x)))))

"""Numpy provides many useful functions for performing computations on arrays; one of the most useful is `sum`:"""

import numpy as np

x = np.array([[1,2],[3,4]])

print(np.sum(x))  # Compute sum of all elements; prints "10"
print(np.sum(x, axis=0))  # Compute sum of each column; prints "[4 6]"
print(np.sum(x, axis=1))  # Compute sum of each row; prints "[3 7]"

"""# Quiz Question 12

What is the sum of all the elements of x and square-root of dot-product of sum of each coloumn of x and sum of each row of x? (answer up to 5 decimal points only, e.g. 0.12345)
"""

print((np.sum(x) + (np.sqrt(np.dot(np.sum(x,axis=0),np.sum(x,axis=1))))))

"""## Broadcasting

Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations. Frequently we have a smaller array and a larger array, and we want to use the smaller array multiple times to perform some operation on the larger array.

For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:
"""

import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = np.empty_like(x)   # Create an empty matrix with the same shape as x

# Add the vector v to each row of the matrix x with an explicit loop
for i in range(4):
    y[i, :] = x[i, :] + v

# Now y is the following
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]
print(y)

"""## Image operations

PIL is the Python Imaging Library by Fredrik Lundh and Contributors. You should learn PIL as we would be using it a lot along with PyTorch
"""

from PIL import Image
import requests
from io import BytesIO

response = requests.get('https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRZpTmijaNOH6MmycM_eiPKcEl5mVvbwl7a8YKVGpEEMIanDcSt')
img = Image.open(BytesIO(response.content))
display(img)

"""Copying a subrectangle from an image:"""

box1 = (150, 150, 300, 300)
box2 = (200, 100, 250, 200)
box3 = (100, 0, 200, 200)
box4 = (100, 400, 200, 200)
box5 = (0, 0, 100, 100)
box6 = (200, 0, 200, 200)
box7 = (0, 0, 200, 200)
box8 = (100, 100, 200, 200)
box9 = (100, 250, 400, 300)
region = img.crop(box1)
display(region)

"""# Quiz Question 13

Which box value shall be used in img.crop such that the colorful Python Logo is completely visible?
"""

region = img.crop(box7)
display(region)

"""## Playing with images"""

from PIL import Image

#Let's first convert our png (4 channel, R, G, B , Alpha) image into jpg (3 channel, R, G, B) image.
img_jpg = Image.new("RGB", img.size, (255, 255, 255))
img_jpg.paste(img)
# display jpg image
display(img_jpg)

#convert our image into numpy array
npimg = np.array(img_jpg)

#convert numpy image back to PIL image and display it
npimg = Image.fromarray(npimg)
display(npimg)

npimg = np.array(img_jpg)
# print(img_jpg.size)
# print(npimg.shape)
# Operation 1: 
# npimg[0:0, 100:100] = 255
# Operation 2: 
# npimg[50:200, 50:200] = 255
# Operation 3: 
# npimg[100:150, 0:100] = 255
# Operation 4: 
# npimg[0:150, 50:200] = 255

npimg = Image.fromarray(npimg)
display(npimg)

"""# Quiz Question 14
Which Operation will hide the Colorful Python logo completely?

# Quiz Question 15
Numpy Axies are (y, x), where as PIL axies are (x, y). True or False?
"""

#quiz question 4
npimg = np.array(img_jpg)
npimg[0:150, 50:200] = 255

npimg = Image.fromarray(npimg)
display(npimg)

#quiz question 5
#it is false

"""## Gradients
Notice how cleanly we calculated (x or y? you can find out if your 15th answer was correct) gradient!
"""

npimg = np.array(img_jpg)
# Gradient Operation
newimg = npimg[:-1, :] - npimg[1:, :]
npimg = Image.fromarray(newimg)
display(npimg)

"""# Quiz Question 16

From the options available below, which operation will give us "other" gradient? (Other means if we got x-gradient above then y-gradients and vice-verse)

1. newimg = npimg[:-1, :] - npimg[1:, :]
2. newimg = npimg[:, 1:] - npimg[1:, :]
3. newimg = npimg[:-1, :] - npimg[:, 1:]
4. newimg = npimg[:, :-1] - npimg[:, 1:]
"""

npimg = np.array(img_jpg)
# Gradient Operation
newimg = npimg[:-1, :] - npimg[1:, :]
npimg = Image.fromarray(newimg)
display(npimg)

"""What you have done above is one of the very important operation as you will see in future. This is used in Loss function as well.

## Convolution

We are going to use filter2D function which is built into OpenCV to perform Convolution.
"""

# import the necessary packages
import numpy as np
from urllib.request import urlopen
import cv2
from matplotlib import pyplot as plt

# METHOD #1: OpenCV, NumPy, and urllib
def url_to_image(url):
	# download the image, convert it to a NumPy array, and then read
	# it into OpenCV format
	resp = urlopen(url)
	image = np.asarray(bytearray(resp.read()), dtype="uint8")
	image = cv2.imdecode(image, cv2.IMREAD_COLOR)
 
	# return the image
	return image

image = url_to_image("https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRZpTmijaNOH6MmycM_eiPKcEl5mVvbwl7a8YKVGpEEMIanDcSt")
from google.colab.patches import cv2_imshow
cv2_imshow(image)

"""# Canny Edge Detection"""

edges = cv2.Canny(image,100,200)
cv2_imshow(edges)

"""## Convolution

As mentioned above we'll use OpenCV's inbuilt function `filter2D` to perform our convolution operation. We are defining a vertical Edge detector below to perform our convolution.
"""

kernel = np.float32([[-1,0,1],[-1,0,1],[-1,0,1]])

dst = cv2.filter2D(image,-1,kernel)
cv2_imshow(dst)

"""# Quiz Question 17
Which kernel among these options will give us horizontal edge? 

1. kernel = np.float32([[-1, -1, -1],[0,0,0],[1,1,1]])
2. kernel = np.float32([[-1, -2, -1],[0,0,0],[1,2,1]])
3. kernel = np.float32([[-4, -1, -4],[0,0,0],[4,1,4]])
4. kernel = np.float32([[-4, -4, -4],[0,0,0],[4,4,4]])
"""

kernel = np.float32([[-1, -1, -1],[0,0,0],[1,1,1]]) # use the correct kernel from above
dst = cv2.filter2D(image,-1,kernel)
cv2_imshow(dst)

"""# Quiz Question 18

What would this kernel do?

*   kernel = 1/9*np.float32([[1,1,1],[1,1,1],[1,1,1]])
"""

kernel = 1/9*np.float32([[1,1,1],[1,1,1],[1,1,1]])
dst = cv2.filter2D(image,-1,kernel)
cv2_imshow(dst)
#this image will give us original image

"""# Quiz Question 19

What would this kernel do?

*   kernal = np.float32([[0,0,0],[0,1,0],[0,0,0]])
"""

kernal = np.float32([[0,0,0],[0,1,0],[0,0,0]])
dst = cv2.filter2D(image,-1,kernel)
cv2_imshow(dst)
# this will give us coloured image

"""# RGB to Grayscale Conversion
There are many ways to convert RGB to Grayscale, below is just one of them (averaging the colors) which we are trying but is wrong.
"""

npimg = np.array(img_jpg)
# this operation is wrong, how can we fix it?
#npimg = np.sum(npimg/3, axis=-1)
npimg = np.sum(npimg, axis=-1)/3
print(npimg.shape)
npimg = Image.fromarray(npimg.astype('uint8'))
display(npimg)

"""# Quiz Question 20
Which is the below is correct way of average the channels to get grayscale image?
1. npimg = np.sum(npimg/3, axis=-1)
2. npimg = np.sum(npimg, axis=-1)/3
"""

npimg = np.sum(npimg, axis=-1)/3 <------- correct answer